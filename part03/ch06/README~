section3. 프로세스 생성과 제어
<데몬 프로그램>
daemon.c 참조
부모프로세스를 닫고, 표준출력과 표준입력을 닫고, setsid로 세션의 리더로 만들면 데몬이 된다.

makedaemon 함수 템플릿
void makedaemon() {
     pid_t pid;
     if((pid = fork()) < 0)
     	     exit(0);

     else if(pid != 0)
             exit(0);
     close(0);
     close(0);
     setsid();
}

section4. 포직스 시그널을 이용한 프로세스간 동기화
<시그널 함수를 사용한 시그널 핸들러 설정>
sighandler_t signal(int signum, sighandler_t handler);
- signum: 처리하기 원하는 시그널 번호
- handler: 처리를 원하는 signum 처리함수

<kill함수, raise함수를 통한 시그널 전달>
int kill(pid_t pid, int sig); //해당 pid에 시그널 전달
int raise(int sig); //자기 자신에게 전달

- pid : 값에 따라 전달되는 프로세스 그룹 또는 프로세스가 달라짐

<네트워크 프로그램과 시그널>

fork를 통해 클라이언트 입력을 처리하였다면, 자식프로세스가 종료될때
좀비프로세스 방지를 위해서(fork를 시키면 부모 프로세스가 자식
프로세스를 기다려야 좀비가 생성이 안되므로), 자식프로세스의 종료 시그널 SIGCHILD를
처리한다
void zombie_handler() {
  int status, spid;
  spid = wait(&status);
}

int main() {
  //생략
  signal(SIGCHLD, (void *)zombie_handler);
  while(1) {
    accept();
    pid = fork();
    if(pid > 0) {
    } else (pid == 0) {
    }
  }
}

section5. IPC: 프로세스간 통신

<pipe함수를 통한 파이프 생성>
pipe.c 참조

#include <unistd.h>
int pipe(int filedes[2]);

소켓의 경우 양방향이 가능하지만, pipe는 안되므로 입/출력 디스크립트를 만든다

<FIFO: 명명 pipe>
fifo_server.c
fifo_client.c

#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char * pathname, mode_t mode);
- pathname : 생성하고자 하는 FIFO파일명
- mode : 일반적인 파일이므로 권한 지정필요

FIFO 통신을 위해 파일을 사용. 입출력을 위해선 두개의 파일이 필요.
하나의 파일로 입출력을 하게 되면, 당연히 꼬임.