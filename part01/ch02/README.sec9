section09. TCP/IP네트워크 데이터 전송 과정의 이해

<이더넷 데이터 구조>
* NIC(이더넷)에서 나가는 데이터 구조

<프레임헤더><IP헤더><TCP헤더><애플리케이션 데이터><트레일러>

- 프레임헤더: mac헤더 또는 물리 헤더라고 불림
- 데이터: IP헤더가 붙은 데이터그램 또는 다른 프로토콜 데이터
- 트레일러: 0이 반복되는 비트열로 프레임 전송이 끝났음을 알림.

* 프레임: IP의 데이터그램, TCP의 세그먼트와 마찬가지로 물리계층의 패킷을 프레임이라고 불림.
패킷은 <목적지물리주소><발신지물리주소><형식><데이터> 형태.

데이터부분을 제외한 앞부분을 프레임 헤더라고 하며, NIC종류마다 구조가 다름. 가장 보편적인 이더넷 프레임헤더의 구조는 Ethernet Version-2 헤더 형식이며, Ethernet-II 헤더라고 부름.

e.g)
네트워크E의 1.1.1.100 -> 네트워크C의 3.3.3.100 의 경우
>> 네트워크E의 컴퓨터(1.1.1.100/MAC:AA:AA:AA:AA:AA:AA)->네트워크E 라우터(1.1.1.1/MAC:BB:BB:BB:BB:BB:BB)->네트워크D->라우터2(2.2.2.1/MAC:CC:CC:CC:CC:CC:CC)->네트워크C의 컴퓨터(3.3.3.100/MAC:DD:DD:DD:DD:DD:DD)

1. 1.1.1.100컴퓨터에서 목적지 IP와 마스킹, 로컬 네트워크가 아니므로 패킷을 게이트웨이로 보내야함.
2. 프레임헤더의 목적지 물리주소를 BB:BB:BB:BB:BB:BB로 발신지 물리주소를 AA:AA:AA:AA:AA:AA로, 목적지IP를 3.3.3.100, 발신지 IP 1.1.1.100으로 보냄. 로컬 네트워크의 다른 컴퓨터에도 전달은 되나, 목적지 물리주소가 맞지않으므로 해당 패킷 버림.
3.게이트웨이 1.1.1.1은 프레임의 목적지가 3.3.3.100이므로 라우팅 테이블에서 가장 가까운 라우터2에, 받은 프레임(패킷을 복사해서?)을 목적지물리주소에 라우터2의 물리주소, 발신지 물리주소를 라우터1로 바꾸고 보냄.
4. 라우터2에서 프레임을 받아들이고, 목적지IP를 보고 자신의 네트워크C의 호스트임을 판단. 받은 프레임(복사해서?)을 목적지 물리 주소에 라우터2 물리주소, 발신지 물리주소에 DD:DD:DD:DD:DD:DD를 넣어 보냄.

※패킷은 IP주소를 보고 최종목적지로 찾아가고, 물리주소를 보고 다음 목적지로 간다는 의미.

<ARP에 의한 물리 주소 변환>
※ 수신지 주소의 물리주소가 테이블에 있는지 찾음, 없으면 ARP패킷을 보냄.
* ARP테이블 보기
- 윈도우: arp -a
- 리눅스: cat /proc/net/arp

게이트웨이, 라우터는 거의 1분마다 주기적으로 물리주소를 로컬 네트워크에 보냄.

※IP주소를 바탕으로 목적지를 찾아가지 않는 이유는 네트워크 프로토콜 중에 IP를 사용하지 않는 프로토콜이 있기 때문(e.g. IPX프로토콜) 

<도메인을 IP로 변환하기>
도메인 접속시 내부적으로 DNS서버로 접속.UDP패킷으로 DNS질의 후 IP주소를 받아옴.

※Ethereal사용시 Capture후 Filter에 dns or http를 입력.
Ethereal은 총 3가지의 출력부분이 있음
1. 어떤 패킷이 캡쳐되었는지 보여주는 부분.
2. 해당 패킷의 논리적 구조와 해당 필드의 값을 보여주는 부분.
3. 해당 패킷의 실제 데이터를 보여주는 부분.

※Ethereal로 웹브라우져에서 웹서버로 보내주는 문자열 확인시, 해당 item선택후 context menu에서 [Follow TCP Stream]선택

<TCP접속 과정>
3웨이 핸드쉐이킹으로 접속.
1. 발신자 -> SYN세그먼트(seq:1500, ack:-)-> 구글서버
2. 발신자 <- SYN,ACK세그먼트(seq: 30, ack:1501) <- 구글서버
3. 발신자 -> ACK세그먼트(seq: 1501, ack: 31) -> 구글서버

* SYN과 ACK는 TCP제어플래그의 해당 비트가 활성화된것을 의미.

<데이터 캡슐화>
아래로 갈수록 데이터가 캡슐화 되면서 붙여져 나감
0. 사용자데이터
1. 애플리케이션(웹브라우져,FTP등): 응용헤더+사용자데이터
2. TCP스택(운영체제): TCP헤더+응용헤더+사용자데이터
3. IP스택(운영체제): IP헤더+TCP헤더+응용헤더+사용자데이터
4. 이더넷디바이스드라이버: Ethernet-II헤더+IP헤더+TCP헤더+응용헤더+사용자데이터

※TCP,IP 스택은 네트워크 프로토콜 스택이라고 부름.
※네트워크 프로토콜 스택은 데이터그램구조에서 데이터추출후 애플리케이션에 전달. 애플리케이션 데이터를 데이터그램 구조로 만드는 역할
<패킷 라우팅>
라우터가 최적의 경로를 알고 있는 이유는, RIP(Routing Information Protocol) or OSPF(Open Shortest Path First) or BGP(Board Gateway Portocol)프르토콜로 주기적으로 라우팅 프로토콜을 최신 정보로 갱신하기 때문.

<목적지 호스트 수신>

1. NIC에 프레임이 들어오면 디바이스 드라이버가 목적지 물리주소가 자신의물리주소/브로드캐스팅주소라면 해당 프레임을 받아들임.
2. 해당 프레임을 OS의 프로토콜 스택으로 올림.
3. 프로토콜 스택에서 목적지IP주소, 포트번호, 체크섬값등을 검사 후, 이상이없으면 데이터를 추출해서 애플리케이션에 전달.


<TCP접속종료>
TCP는 4웨이 핸드쉐이킹
1. 발신지 -> FIN세그먼트(seq:1800, ack:- ) -> 구글서버
2. 발신지 <- ACK세그먼트(seq:50, ack:1801 ) <- 구글서버
3. 발신지 <- FIN세그먼트(seq:51, ack:1801 ) <- 구글서버
4. 발신지 -> ACK세그먼트(seq:1801, ack:52 ) -> 구글서버